package week05;

/**
 * @author : sh Lee
 * @date : 22. 12. 29.
 */

/**
 * 아이디어
 * 1. 모든 경우를 다 탐색해봐야되는 문제.
 * 2. 조합,순열과 같이 모든 경우를 일일이 하기에는 너무 데이터가 큼
 *    배열의 크기가 10만인데, 스티커를 하나 뜯으면 양쪽을 전부 못쓰기 때문에 한번에 3개씩 소모가 되기 때문에, 총 뜯을 수 있는 스티커의 수는 33333개가 된다.
 *    33333! => 펑 (정확히는 33333!은 아니지만 대충 계산해도 엄청크게 나옴.)
 *    따라서 dp 또는 그리디로 풀어야 하는데, 그리디로 생각하고, 매 번 뜯을 수 있는 최대값만 선택하는 식으로 생각하면, 최대가 된다는 보장이 없다.
 *    처음 선택한 수가 14라서 14를 뜯었는데, 양쪽의 수가 각각 12,13이고 다음으로 뜯을 수 있는 수가 굉장히 작은 수지만, 이것을 뜯어야 된다면 최대가 될수 없다.
 *    12 14 13 1 2 3 => 대충 이런식일때, 14를 뜯지 않고, 12와 13을 뜯게 되면 더 큰 수를 얻을 수 있다는 뜻이다.
 *    즉, 그리디처럼 생각해서는 풀 수 없고, 모든 경우를 다 해봐야 하는데, 배열의 수가 많고, 이전에 계산된값이 중복되는 형태이므로 dp를 사용하는 것이 맞다고 생각한다.
 *3. dp로 해결해야 되며, 각 각의 위치를 뜯었을때, 나올수 있는 숫자의 합을 업데이트 하는 식으로 계산해준다.
 *4. {12,14,13,1,2,3} 이라고 했을때, 2번째 위치(13)을 뜯을 수 있는 경우는, 12를 뜯는 경우,3을 뜯는 경우, 이런식으로 해당위치를 뜯을 수 있는 경우중 가장 큰값으로 업데이트를 한다.
 *
 * 주의해야 할 점 : 원형 큐 형태이므로 -1이면 맨 끝 인덱스로 돌려놓는 작업이 필요함.
 *
 * 1번아이디어(실패)
 * //해당 위치까지의 최대값은 두가지 경우가 있다. - 둘중에 더 큰 값으로 저장해둔다.
 * // i번째를 떼는 경우. - i번째 위치의 값 + (i-2)번째 위치까지 누적된 최대 값 => i를 떼면 i-1번째를 뗄수 없음.
 * // i번째를 떼지 않는 경우. - i-1번째 위치까지 누적된 값.
 * 실패 이유 : 그리디 처럼 되어버렸다. 시작시에는 첫번째 값이 누적되어있지 않기 때문에 무조건 시작 위치의 스티커를 떼고 시작해버린다.
 * 하지만 위에서 이야기 한 것 처럼 시작위치의 스티커를 떼지 않았을 때가 더 최적일 수도 있다.
 *
 * 2번 아이디어
 * 그렇다면, 첫번째를 떼고 시작하는 경우와, 안떼고 시작하는 경우 두가지로 생각한다면
 * 빙고
 *
 * 주의해야할 점, 스티커 배열 길이가 1이면 첫번째 스티커를 떼고 시작하는 경우, 인덱스 에러가 난다.
 *
 *
 */
public class Programmers_스티커_모으기2 {


    public int solution(int sticker[]) {
        int answer = 0;

        int len = sticker.length;

        if(len == 1) return sticker[0];
        else if(len == 2) return Math.max(sticker[0], sticker[1]);
        else if(len == 3) return Math.max(sticker[0], Math.max(sticker[1],sticker[2]));

        int[] dp1 = new int[len]; //시작 스티커를 떼고 시작하는 경우.
        dp1[0] = sticker[0];
        // 첫번째 스티커를 떼고 시작하는 경우이므로, 아래의 두 위치는 첫번째 값이 저장되어야 함.
        dp1[1] = sticker[0];
        dp1[len-1] = sticker[0];

        int[] dp2 = new int[len]; //시작 스티커를 떼지 않고 시작하는 경우.

        //시작 스티커를 떼고 시작하는 경우 - 2번부터 시작해야 되고, 원형큐 형태이므로 마지막값 -1 까지 가야됨.
        for(int i = 2; i < len-1; i++){

            //해당 위치까지의 최대값은 두가지 경우가 있다. - 둘중에 더 큰 값으로 저장해둔다.
            // i번째를 떼는 경우. -> i번째 위치의 값 + (i-2)번째 위치까지 누적된 최대 값 => i를 떼면 i-1번째를 뗄수 없음.
            // i번째를 떼지 않는 경우. -> i-1번째 위치까지 누적된 값.
            dp1[i] = Math.max(sticker[i] + dp1[(i-2 + len)%len], dp1[(i-1 + len)%len]);
        }

        // 시작 스티커를 안떼고 시작하는 경우 - 1번째부터 시작하면 됨.
        for(int i = 1; i < len; i++){
            dp2[i] = Math.max(sticker[i] + dp2[(i-2 + len)%len], dp2[(i-1 + len)%len]);
        }

        return Math.max(dp1[len-2], dp2[len-1]);
    }
}
